# ДЗ на практику Анонимных классов, лямбд и Stream-api

### **Задача 0 (Опционально): Реализация собственного класса `Optional`**
**Описание:** Вам необходимо реализовать свой собственный класс `MyOptional<T>`, который будет аналогичен `java.util.Optional<T>`. Класс должен поддерживать основные методы, такие как:
- `of(T value)`: Создаёт `MyOptional` с заданным значением.
- `empty()`: Создаёт пустой `MyOptional`.
- `isPresent()`: Проверяет, содержит ли `MyOptional` значение.
- `get()`: Возвращает значение, если оно присутствует, иначе бросает исключение.
- `ifPresent(Consumer<? super T> consumer)`: Выполняет действие, если значение присутствует.
- `map(Function<? super T, ? extends U> mapper)`: Применяет функцию к значению, если оно присутствует, и возвращает новый `MyOptional`.
- `flatMap(Function<? super T, MyOptional<U>> mapper)`: Применяет функцию, возвращающую `MyOptional`, к значению, если оно присутствует.
- `orElse(T other)`: Возвращает значение, если оно присутствует, иначе возвращает `other`.

**Требования:**
1. Реализуйте класс `MyOptional<T>` с вышеописанными методами.
2. Обеспечьте корректную работу методов при наличии и отсутствии значения.
3. Напишите тесты для проверки функциональности вашего класса.

**Цель:** Понять внутреннюю реализацию `Optional` и улучшить навыки работы с обобщениями и функциональными интерфейсами в Java.

---

### **Задача 1: Фильтрация четных чисел**
**Описание:** Дана коллекция целых чисел. Используя Stream API, отфильтруйте и выведите только четные числа.

### **Задача 2: Преобразование строк в верхний регистр**
**Описание:** Имеется список строк. С помощью Stream API преобразуйте все строки в верхний регистр и выведите результат.

### **Задача 3: Сумма элементов списка**
**Описание:** Дана коллекция чисел. Используя Stream API, вычислите и выведите сумму всех элементов.

### **Задача 4: Поиск уникальных элементов**
**Описание:** Имеется список с повторяющимися элементами. Используя Stream API, найдите и выведите уникальные элементы списка.

### **Задача 5: Сортировка и ограничение результатов**
**Описание:** Дана коллекция строк. Используя Stream API, отсортируйте строки по алфавиту и выведите первые 5 элементов.

### **Задача 6: Группировка объектов по полю**
**Описание:** Имеется список объектов класса `Person` с полями `name` и `age`. С помощью Stream API сгруппируйте людей по возрасту и выведите результат.

### **Задача 7: Среднее значение по полю**
**Описание:** Дана коллекция объектов класса `Employee` с полем `salary`. Используя Stream API, вычислите среднюю зарплату сотрудников.

### **Задача 8: Обработка вложенных коллекций**
**Описание:** Имеется список списков целых чисел. Используя Stream API, "разверните" вложенные списки в один поток и найдите максимальное число.

### **Задача 9: Сложные фильтры и маппинг**
**Описание:** Дана коллекция объектов класса `Product` с полями `name`, `category` и `price`. Используя Stream API, выберите продукты из категории "Electronics" с ценой выше 1000, преобразуйте их названия в верхний регистр и соберите в список.

### **Задача 10: Параллельная обработка и оптимизация**
**Описание:** Имеется большой список транзакций (`Transaction`), каждая из которых имеет поле `amount`. Используя параллельные стримы, найдите общую сумму транзакций, оптимизируя производительность обработки.

---

### **Задача 11: Комплексная агрегация данных**
**Описание:** Имеется список объектов класса `Order` с полями `id`, `customerId`, `amount` и `status`. Используя Stream API, сгруппируйте заказы по `customerId`, вычислите общую сумму заказов для каждого клиента и отфильтруйте клиентов с общей суммой выше 10,000. Выведите список таких клиентов с их общей суммой заказов.

### **Задача 12: Создание мапы из списка с преобразованием**
**Описание:** Дана коллекция объектов класса `Student` с полями `studentId`, `name` и `grades` (список оценок). Используя Stream API, создайте `Map<Integer, Double>`, где ключ — `studentId`, а значение — средняя оценка студента. Игнорируйте студентов без оценок.

### **Задача 13: Объединение нескольких потоков данных**
**Описание:** Имеются два списка: список `employees` (с полями `id`, `name`, `departmentId`) и список `departments` (с полями `departmentId`, `departmentName`). Используя Stream API, создайте список строк в формате `"EmployeeName - DepartmentName"` для всех сотрудников, сопоставляя их с соответствующими департаментами.

### **Задача 14: Обработка Optional значений**
**Описание:** Дана коллекция объектов класса `User` с полями `id`, `name` и `address`. Поле `address` является объектом класса `Address` с полями `street`, `city` и `zipcode`. Некоторые пользователи могут не иметь адреса (`address` может быть `null`). Используя Stream API, соберите список уникальных городов, в которых проживают пользователи.

### **Задача 15: Пользовательские коллекторы и многократная агрегация**
**Описание:** Имеется список объектов класса `Transaction` с полями `id`, `type` (например, "DEBIT", "CREDIT"), `amount` и `timestamp`. Используя Stream API и пользовательские коллекторы, сгруппируйте транзакции по дате (без времени) и для каждой даты вычислите общую сумму "DEBIT" и "CREDIT" транзакций. Результатом должна быть карта, где ключ — дата, а значение — объект с полями `totalDebit` и `totalCredit`.

---

### **Дополнительные пояснения:**

1. **Задача 0:** Реализация собственного `Optional` поможет глубже понять концепцию контейнеров для возможных значений и работу с обобщениями.
2. **Задача 1:** Использование filter для отбора четных чисел.
3. **Задача 2:** Применение map для преобразования строк.
4. **Задача 3:** Использование reduce или sum для вычисления суммы.
5. **Задача 4:** Применение distinct для получения уникальных элементов.
6. **Задача 5:** Использование sorted и limit для сортировки и ограничения результатов.
7. **Задача 6:** Применение Collectors.groupingBy для группировки объектов.
8. **Задача 7:** Использование Collectors.averagingDouble для вычисления среднего.
9. **Задача 8:** Использование flatMap для обработки вложенных коллекций.
10. **Задача 9:** Комбинация фильтров, маппинга и сбора результатов.
11. **Задача 10:** Применение параллельных стримов (parallelStream) для улучшения производительности на больших данных.
12. **Задачи 1-10:** Эти задачи охватывают базовые операции с потоками, такие как фильтрация, преобразование, агрегация, группировка и параллельная обработка.
13. **Задача 11:** Включает в себя группировку с последующей агрегацией и фильтрацией на основе агрегированных данных.
14. **Задача 12:** Требует создания мапы из списка объектов с вычислением среднего значения и обработкой возможных исключений (например, отсутствие оценок).
15. **Задача 13:** Объединение данных из двух разных списков посредством сопоставления ключей (`departmentId`), что аналогично операциям JOIN в базах данных.
16. **Задача 14:** Работа с вложенными объектами и `Optional`, чтобы избежать `NullPointerException` при обработке потенциально отсутствующих данных.
17. **Задача 15:** Создание пользовательских коллекторов для сложной агрегации данных, включая группировку по дате и раздельный подсчет по типам транзакций.