## 1. Apache Tomcat

### 1.1. Кратко

Контейнер сервлетов от Apache Software Foundation, реализующий спецификации **Servlet**, **JSP**, **WebSocket** и работаю­щий поверх **BIO** или **NIO** коннекторов.

### 1.2. Архитектура и модель

* **Connector** (HTTP/1.1, AJP) — слушает сокеты, передаёт запросы в **Container**.
* **Container**:

    * **Engine** → **Host** → **Context** → **Wrapper** (каждый сервлет).
* По умолчанию использует **Blocking I/O** (`BIO`), но с версии 6 поддерживает **NIO** и **APR/native**.

### 1.3. Встраивание в Spring Boot

При наличии `spring-boot-starter-web` автоматически создаётся встраиваемый Tomcat (по умолчанию порт 8080). Можно настроить в `application.properties`:

```properties
server.tomcat.max-threads=200
server.tomcat.min-spare-threads=10
server.tomcat.accept-count=100
server.port=8081
```

### 1.4. Плюсы и минусы

* **Плюсы:**

    * Полная совместимость с Java EE Web-спецификациями.
    * Богатая экосистема, зрелость, масса документации.
* **Минусы:**

    * Модель поток-на-запрос (каждый HTTP-запрос блокирует поток), что может приводить к большому потреблению памяти под высокую нагрузку.
    * Менее гибкая по сравнению с легковесными реактивными серверами.

---

## 2. Eclipse Jetty

### 2.1. Кратко

Лёгковесный сервер сервлетов и HTTP-контейнер, также поддерживает **Servlet**, **JSP**, **WebSocket**, **HTTP/2** и **ALPN**.

### 2.2. Архитектура и модель

* Основан на **NIO** и **Asynchronous I/O** (Java NIO2), что позволяет эффективно обслуживать тысячи одновременных соединений.
* Поддержка **embedded**-режима: легко встраивается как библиотека без внешней конфигурации.

### 2.3. Встраивание в Spring Boot

Добавьте зависимость `spring-boot-starter-jetty` вместо `tomcat`. Можно тонко конфигурировать:

```properties
server.jetty.threadPool.maxThreads=200
server.jetty.acceptors=2
server.jetty.selectors=4
```

### 2.4. Плюсы и минусы

* **Плюсы:**

    * Хорошая производительность на большом числе одновременных соединений.
    * Гибкая конфигурация через Java API.
* **Минусы:**

    * Реже используется в корпоративных средах, чем Tomcat.
    * Требует более точной настройки пулов потоков под конкретную нагрузку.

---

## 3. Netty

### 3.1. Кратко

Низкоуровневый **asynchronous event-driven** сетевой фреймворк, не привязан к Servlet API, предназначен для создания собственных TCP/UDP-протоколов и высокопроизводительных HTTP-серверов.

### 3.2. Архитектура и модель

* **EventLoopGroup** — группа потоков (обычно по числу ядер × 2), на которых работают **EventLoop**.
* **ChannelPipeline** — цепочка **ChannelHandler**’ов, обрабатывающих входящие/исходящие события (декодирование, обработка логики, кодирование).
* **Non-blocking I/O** через Java NIO, минимальные накладные расходы на переключение контекста.

### 3.3. Встраивание в Spring Boot

Через `spring-boot-starter-webflux` по умолчанию используется **Netty** (т.е. приложение на Spring WebFlux будет работать на Netty). Конфигурация:

```properties
server.netty.threads=200
spring.webflux.base-path=/api
```

### 3.4. Плюсы и минусы

* **Плюсы:**

    * Максимальная производительность и масштабируемость для реактивных приложений.
    * Поддержка кастомных протоколов (MQTT, custom TCP).
* **Минусы:**

    * Более высокий порог вхождения: нужно разбираться в EventLoop, Channel и ByteBuf.
    * Не реализует стандарт Servlet API — подходит лишь в WebFlux или для самостоятельных серверов.

---

## 4. Undertow

### 4.1. Кратко

Лёгкий высокопроизводительный веб-сервер от Red Hat (WildFly), построенный на **XNIO**, поддерживает **Servlet 3.1**, **WebSocket**, **HTTP Upgrade**, **AJP**.

### 4.2. Архитектура и модель

* Основан на **non-blocking I/O**, использует неблокирующие **Worker** и **I/O Threads**.
* **Handler chains** — подобно Netty, но уже реализующий Servlet API.

### 4.3. Встраивание в Spring Boot

Используется через зависимость `spring-boot-starter-undertow`. Конфигурация:

```properties
server.undertow.worker-threads=200
server.undertow.io-threads=8
server.undertow.buffer-cache-size=1024
```

### 4.4. Плюсы и минусы

* **Плюсы:**

    * Высокая производительность и низкая задержка.
    * Поддержка HTTP/2 без дополнительных модулей.
* **Минусы:**

    * Меньшее коммьюнити, чем Tomcat/Jetty.
    * Конфигурация через Undertow-specific API бывает менее очевидной.

---

## 5. Сравнительная таблица

| Сервер       | Модель I/O        | Servlet API | HTTP/2                | Встраивание   | Подходит для                            |
| ------------ | ----------------- | ----------- | --------------------- | ------------- | --------------------------------------- |
| **Tomcat**   | BIO / NIO / APR   | да          | с 9.0                 | через Starter | Стандартные веб-приложения              |
| **Jetty**    | NIO, Async I/O    | да          | да                    | через Starter | Высокая конкуренция соединений          |
| **Netty**    | NIO, event-driven | нет         | реализуется в WebFlux | через WebFlux | Реактивные сервисы, кастомные протоколы |
| **Undertow** | NIO, XNIO         | да          | да                    | через Starter | Лёгкие микросервисы с HTTP/2            |

---

## 6. Выбор сервера

* Если вам **нужен стандартный** Servlet-контейнер с проверенной экосистемой — **Tomcat**.
* Если требуется **асинхронная** обработка большого числа соединений при сохранении Servlet API — **Jetty** или **Undertow**.
* Если вы пишете **реактивное** приложение на **WebFlux**, особенно с кастомными протоколами — **Netty**.
* Если нужна **HTTP/2** «из коробки» и вы хотите минимальную нагрузку — **Undertow**.
