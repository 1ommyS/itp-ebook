## 1. Общее описание проекта

**Проект: Система бронирования билетов на киносеансы**

Цель проекта – разработать систему, которая позволит пользователям просматривать расписание киносеансов, бронировать билеты (с учетом имеющихся свободных мест) и управлять бронированиями. Проект должен включать:
- Небольшую реляционную базу данных.
- Слой доступа к данным (Repository) с реализацией через JDBC.
- Сервисный слой с бизнес-логикой:
    - Валидация запросов.
    - Проверка доступности мест.
    - Правила скидок (например, скидка при покупке нескольких билетов или для определенных категорий пользователей).
- Набор модульных тестов:
    - Тесты бизнес-логики с использованием JUnit.
    - Применение Mockito для имитации зависимостей (например, репозиториев) при тестировании сервисов.
- Контейнеризацию приложения через Docker (docker-compose для развертывания БД).

---

## 2. Структура проекта

### 2.1. База данных

Создайте небольшую БД (например, на MySQL, PostgreSQL или H2) с таблицами:

- **movies** – информация о фильмах:
    - `id` (PK)
    - `title`
    - `duration` (в минутах)
    - `genre`
    - `description`

- **cinema_halls** – залы кинотеатра:
    - `id` (PK)
    - `name`
    - `total_seats`

- **showtimes** – сеансы:
    - `id` (PK)
    - `movie_id` (FK на movies)
    - `hall_id` (FK на cinema_halls)
    - `start_time` (дата и время начала сеанса)

- **bookings** – бронирования билетов:
    - `id` (PK)
    - `showtime_id` (FK на showtimes)
    - `user_name`
    - `number_of_seats`
    - `booking_time` (время бронирования)

### 2.2. Слой доступа к данным ( Repository)

Напишите классы, которые будут работать с БД через JDBC, выполняя CRUD-операции:
- **MovieRepository**:
    - Получение списка фильмов.
    - Поиск фильма по идентификатору.
- **CinemaHallRepository**:
    - Получение информации о зале.
- **ShowtimeRepository**:
    - Получение расписания киносеансов.
    - Поиск сеансов по определенному фильму или залу.
- **BookingRepository**:
    - Создание нового бронирования.
    - Получение бронирований для конкретного сеанса (для проверки доступности мест).

### 2.3. Сервисный слой

Создайте классы сервисов, реализующих бизнес-логику. Пример – **BookingService**:
- **Основные функции:**
    - При бронировании билетов выполняется проверка:
        1. Существует ли сеанс с указанным идентификатором?
        2. Достаточно ли свободных мест в зале (учитывая уже сделанные бронирования)?
    - **Интересная бизнес-логика:**
        - Реализуйте правило скидок:  
          _Например_, если пользователь бронирует более 5 билетов за одну транзакцию, то применяется скидка 10% на всю сумму.
        - Если сеанс начинается менее чем за 15 минут, бронирование недоступно.
- Дополнительные сервисы:
    - **ShowtimeService**: может включать функции по фильтрации сеансов, сортировке и обновлению информации.
    - **MovieService**: может включать функции для просмотра подробной информации о фильме, рекомендаций на основе жанра и т.п.

_Обратите внимание:_ Логика должна учитывать транзакционность. Например, создание бронирования должно гарантировать, что данные не изменились к моменту фиксации бронирования.

### 2.4. Тестирование

Покройте тестами важнейшие компоненты проекта:

#### Юнит-тестирование с JUnit
- Напишите тесты для каждого сервиса:
    - Тесты на бронирование билетов с различными сценариями:
        - Успешное бронирование при наличии мест.
        - Попытка бронирования с превышением лимита свободных мест.
        - Тесты по правилу скидок (проверка правильного расчёта цены).
        - Тестирование проверки времени начала сеанса (например, блокировка бронирования, если осталось менее 15 минут).

#### Использование Mockito
- При тестировании сервисного слоя замокайте (imitate) зависимости от репозиториев, чтобы сконцентрироваться на бизнес-логике.
    - Пример: при тестировании метода бронирования билетов в **BookingService** замокайте **ShowtimeRepository** и **BookingRepository**, чтобы возвращать заранее подготовленные данные (например, уже забронированные места).
- Проверьте, что сервис корректно реагирует на возвращаемые значения (например, выбрасывает исключения, если недостаточно мест).

_Пример сценария:
1. Вызывается метод бронирования в BookingService.
2. Mockito возвращает из BookingRepository текущее количество уже забронированных мест.
3. На основании этого BookingService решает, можно ли добавить еще бронирование.
4. Если всё корректно, бронирование сохраняется; если нет – выбрасывается исключение, которое тоже проверяется тестами.

### 2.5. Docker-контейнеризация
#### Docker-compose
- Создайте файл `docker-compose.yml`, который поднимает:
    - Контейнер для БД (PostgreSQL). Задайте стандартные переменные окружения для инициализации.
_Пример docker-compose.yml:_

```yaml
version: "3.8"
services:
  db:
    image: postgresql:16.0
    environment:
      POSTGRESQL_DATABASE: cinema_db
      POSTGRESQL_ROOT_PASSWORD: root
      POSTGRESQL_USER: user
      POSTGRESQL_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - db-data:/var/lib/postgresql/data
volumes:
  db_data:
```

---

## 3. Требования к выполнению домашнего задания

1. **Проект и исходный код:**
    - Проект должен быть оформлен как Maven/Gradle проект.
    - Структура кода должна быть разделена на пакеты: repository, services, models (для сущностей), tests.

2. **База данных:**
    - Схема БД должна быть представлена в виде SQL-скриптов.

3. **Сервисный слой и бизнес-логика:**
    - Реализуйте проверку доступности билетов.
    - Добавьте нетривиальную логику по применению скидок.
    - Используйте транзакции для обеспечения целостности данных.

4. **Тестирование:**
    - Покройте основные сценарии бронирования, проверки лимитов, правильного расчёта скидок.
    - Используйте Mockito для имитации зависимостей и JUnit для утверждений.

5. **Итог:**
    - Предоставьте README-файл с описанием функциональности.

## 4. Рекомендации по реализации

1. **Проектирование базы данных:**
    - Четко опишите взаимосвязь между таблицами и определите ограничения целостности (foreign keys, уникальные ключи).
    - Добавьте необходимые индексы для ускорения выборок (при необходимости).

2. **Работа с JDBC:**
    - Разработайте абстрактный класс для работы с базой, который будет отвечать за установку и закрытие соединений.
    - При работе с данными обязательно обеспечьте обработку исключений и корректное закрытие ресурсов.

3. **Бизнес-логика в сервисах:**
    - Создайте интерфейсы для ваших сервисов, чтобы была возможность легко переключаться на другие реализации.
    - Добавьте валидацию входных данных. Например, если приходит запрос на бронирование, проверьте, что количество билетов положительное.

4. **Тесты с использованием JUnit и Mockito:**
    - Разбейте тесты на группы: positive cases (успешное бронирование) и negative cases (недостаток мест, неверное время и т.п.).
    - Пример использования Mockito:
      ```java
      @Mock
      private ShowtimeRepository showtimeRepository;
      
      @BeforeEach
      void setUp() {
          MockitoAnnotations.openMocks(this);
          bookingService = new BookingService(showtimeRepository, bookingRepository);
      }
      
      @Test
      void testBookingWhenEnoughSeats() {
          // Настройте мок так, чтобы вернуть доступное количество мест
          when(showtimeRepository.getBookedSeats(showtimeId)).thenReturn(50);
          // Проведите тест и проверьте результат
          BookingResult result = bookingService.bookTickets(showtimeId, "Ivan Ivanov", 5);
          assertTrue(result.isSuccess());
      }
      ```
    - Покрывайте тестами как положительные, так и отрицательные сценарии.

5. **Контейнеризация:**
    - Тестируйте запуск вашего приложения через docker-compose локально.
    - Убедитесь, что настройки подключения к базе читаются из переменных окружения.

---

## 5. Сдача и оценка работы

**Ожидаемые результаты:**
- Исходный код проекта с разделенной логикой (DAO, сервисы, модели, тесты).
- SQL-скрипты для создания базы данных.
- Набор тестов с использованием JUnit/Mockito.
- docker-compose.yml для контейнеризации приложения.
- Документация (README) с инструкциями по сборке и запуску.