## 1. Что такое шардирование и зачем оно нужно

**Шардирование** (от англ. sharding) — это стратегия горизонтального или вертикального рас­пределения данных между множеством независимых узлов (шардов), при которой каждый шард хранит свою часть общей базы данных.

**Цели шардирования:**

1. **Масштабирование записи и хранения** — каждая нода обрабатывает лишь часть нагрузки.
2. **Улучшение производительности** — меньше данных на каждый сервер → быстрее поиск.
3. **Отказоустойчивость** — падение одного шарда не делает всю систему недоступной.
4. **Географическое распределение** — данные пользователей одного региона хранятся «близко» к ним.

---

## 2. Основные виды шардирования

### 2.1. Горизонтальное шардирование (Horizontal Sharding)

Разбиение **по строкам**: каждая шард-таблица имеет ту же структуру, но хранит свой диапазон или подмножество строк.

#### 2.1.1. Range Sharding (шардирование по диапазону)

* **Идея:** разбить пространство ключей на непрерывные диапазоны.
* **Пример:** по дате:

    * Шард A: `user_id < 10000`
    * Шард B: `10000 ≤ user_id < 20000`
* **Плюсы:**

    * Легко понять и отладить.
    * Диапазоны могут отвечать реальным бизнес-сценариям (например, новые пользователи).
* **Минусы:**

    * «Горячий» шард, если запросы/записи неверно равномерно распределены.
    * При расширении потребуется перескладывать (режистрация «перераспределение»).

#### 2.1.2. Hash Sharding (шардирование по хешу)

* **Идея:** применять хеш-функцию (например, `hash_mod(user_id, N)`) и по результату направлять в один из N шардов.
* **Плюсы:**

    * Равномерное распределение нагрузки при хорошем хеше.
    * Простейшее масштабирование «добавить новую ноду → увеличить N».
* **Минусы:**

    * **Ре-шардинг** (изменение N) требует перералопикировки почти всех записей.
    * Нет «смысловых» диапазонов — сложно делать диапазонные запросы.

#### 2.1.3. Directory-Based Sharding (директори-шардирование)

* **Идея:** держать централизованную таблицу (каталог), где каждому ключу или диапазону ключей сопоставлен нужный шард.
* **Плюсы:**

    * Гибкость: можно вручную переназначать ключи между шардов.
    * Лёгкий контроль «где лежит что».
* **Минусы:**

    * Каталог становится **единой точкой отказа** и узким местом.
    * При большом числе ключей каталог растёт и требует кэширования.

#### 2.1.4. Composite Sharding (композитное шардирование)

* **Идея:** сочетание двух или более методов (например, сначала range, внутри диапазона — hash).
* **Пример:**

    * Сначала по региону (range: Европа, Азия, Америка),
    * затем внутри каждого региона по хешу `user_id mod 4`.
* **Плюсы:**

    * Позволяет учитывать две оси масштабирования (гео и нагрузка).
* **Минусы:**

    * Сложнее в настройке и отладке.
    * Нужна логика маршрутизации на клиенте или прокси.

---

### 2.2. Вертикальное шардирование (Vertical Sharding)

Разбиение **по столбцам**: разные таблицы (или наборы столбцов одной таблицы) хранятся на разных нодах.

* **Идея:** отделить «горячие» поля (часто читаемые/пишемые) от «холодных» (редко используемых).
* **Пример:**

    * Нода A: хранит `users(id, name, email)`
    * Нода B: хранит `user_profiles(id, bio, avatar, settings)`
* **Плюсы:**

    * Снижает I/O на каждой ноде за счёт узкой таблицы.
    * Позволяет масштабировать разные части схемы независимо.
* **Минусы:**

    * JOIN между нодами становится **сети-тревожащим** (cross-shard JOIN).
    * Увеличивается сложность транзакционной целостности.

---

### 2.3. Функциональное шардирование (Functional Sharding)

Разделение по бизнес-функции или типу данных.

* **Идея:** разные сущности (orders, payments, logs) живут в разных базах/шардах.
* **Пример:**

    * Шард A: все таблицы, связанные с пользователями и сессиями.
    * Шард B: платежи и финансовые записи.
* **Плюсы:**

    * Логическое разграничение — команды развёртывают и обслуживают только свою часть.
* **Минусы:**

    * Между functional shards могут понадобиться двунодовые транзакции → сложнее согласованность.

---

### 2.4. Географическое шардирование (Geo Sharding)

Данные помещаются в шард, расположенный ближе к пользователю по гео-локации.

* **Идея:**

    * Европейские пользователи → шард в ЕС
    * Азиатские пользователи → шард в Сингапуре
* **Плюсы:**

    * Минимизируем latency для пользователей.
    * Упрощаем соответствие локальным законам о хранении данных (GDPR).
* **Минусы:**

    * Cross-region JOIN и аналитика усложняются.
    * Возможны «горячие» регионы.

---

## 3. Транзакции и целостность при шардировании

1. **Одно-шардовые транзакции**
   – ACID-гарантии сохраняются на одной ноде.
2. **Межшардовые транзакции**
   – Двухфазный коммит (2PC) или saga-паттерн → сложно, часто заменяют асинхронными процедурами и компенсациями.
3. **Изолированность и консистентность**
   – Обычно выбирают Eventual Consistency или оптимистичные сценарии при межшардовых операциях.

---

## 4. Роутинг запросов и прокси-уровень

* **Клиентская библиотека**
  – знание шард-ключа → напрямую стучится в нужный шард.
* **Прокси-слой** (ProxySQL, Vitess, Pgpool-II)
  – абстрагирует логику маршрутизации, поддерживает кэш, балансировку.
* **Routing Table**
  – хранит правила: `WHERE user_id BETWEEN … → shard_1`, `… MOD n → shard_k` и т. д.

---

## 5. Ребалансировка (Resharding)

### 5.1. Горизонтальная ребалансировка

* **Онлайн-миграция**: постепенно копируем часть диапазона или хешей на новую ноду, переводя трафик, когда готово.
* **Инструменты:**

    * Kafka + MirrorMaker («запись» транзакций в стрим, «плейбек» на новый шард).
    * pt-osc / gh-ost для MySQL (онлайн-миграции таблиц).
    * `pg_repack`, logical replication slots для PostgreSQL.

### 5.2. Вертикальная ребалансировка

* При росте частоты чтения/записи в одном наборе столбцов — «выдергиваем» их на отдельную ноду.

### 5.3. Обходные решения

* **Blue–Green Sharding**: новая схема живёт параллельно, постепенно переключаем часть клиентов.
* **Feature Flags**: переключение маршрутов по флагам.

---

## 6. Плюсы и минусы разных видов шардирования

| Вид                 | Плюсы                                              | Минусы                                                 |
| ------------------- | -------------------------------------------------- | ------------------------------------------------------ |
| **Range**           | Простейший контроль, понятен бизнес-диапазонам     | Горячие шарды, сложный ре-шардинг                      |
| **Hash**            | Равномерное распределение, простая логика          | Полный ре-шардинг при изменении числа шардов           |
| **Directory-Based** | Гибкость маршрутизации                             | Централизованный каталог → SPOF                        |
| **Composite**       | Учитывает несколько осей (гео + нагрузка)          | Сложный роутинг и отладка                              |
| **Vertical**        | Масштабирование горячих полей независимо           | Cross-shard JOIN, сложная целостность                  |
| **Functional**      | Чёткое разделение ответственности                  | Транзакции между сервисами, консистентность            |
| **Geo**             | Минимум latency, локальное соответствие стандартам | Разнесённая аналитика и сложность межрегиональных JOIN |

---

## 7. Практические советы

1. **Выбирайте шард-ключ вдумчиво**:
    * Он должен быть **статичен** (не менять значение).
    * Равномерно распределять нагрузку.
2. **Избегайте «горячих» шардов**: анализируйте реальную QPS по ключам.
3. **Планируйте ре-шардинг заранее**: автоматизируйте миграцию диапазонов или хешей.
4. **Используйте proxy-слой**: чтобы не вносить логику шардирования во все клиенты.
5. **Мониторьте метрики**: загрузку CPU, I/O, network, lag при копировании данных.
6. **Тестируйте отказоустойчивость**: имитируйте отключение шардов и проверяйте, как работает маршрутизация и резервирование.
