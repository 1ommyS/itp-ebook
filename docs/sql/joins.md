## 1. INNER JOIN (внутреннее соединение)

### 1.1. Описание

Возвращает только те строки, для которых найдено совпадение по условию в обеих таблицах.

### 1.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
INNER JOIN B
  ON A.поле = B.поле;
```

### 1.3. Пример

```sql
SELECT u.id, u.username, o.id AS order_id, o.total
FROM users u
INNER JOIN orders o
  ON u.id = o.user_id;
```

* **Результат**: только пользователи, у которых есть заказы.

### 1.4. Особенности

* Синоним: просто `JOIN` без ключевого слова `INNER`.
* При нескольких условиях: `ON A.x = B.x AND A.y = B.y`.
* Не включает строки без совпадений.

---

## 2. LEFT \[OUTER] JOIN (левое внешнее соединение)

### 2.1. Описание

Возвращает все строки из **левой** (первой) таблицы и только совпадающие из правой. Если для строки левой таблицы не нашлось совпадений — поля правой будут `NULL`.

### 2.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
LEFT [OUTER] JOIN B
  ON A.поле = B.поле;
```

### 2.3. Пример

```sql
SELECT u.id, u.username, o.id AS order_id
FROM users u
LEFT JOIN orders o
  ON u.id = o.user_id;
```

* **Результат**: все пользователи, у кого нет заказов — получат `order_id = NULL`.

### 2.4. Особенности

* `OUTER` можно опустить: `LEFT JOIN`.
* Полезно для поиска «несвязанных» записей (например, `WHERE o.id IS NULL`).

---

## 3. RIGHT \[OUTER] JOIN (правое внешнее соединение)

### 3.1. Описание

Симметричен `LEFT JOIN`, но возвращает все строки из **правой** таблицы и совпадения из левой.

### 3.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
RIGHT [OUTER] JOIN B
  ON A.поле = B.поле;
```

### 3.3. Пример

```sql
SELECT u.id, o.id AS order_id, o.total
FROM users u
RIGHT JOIN orders o
  ON u.id = o.user_id;
```

* **Результат**: все заказы, даже если для них нет пользователя (хотя такое бывает редко).

### 3.4. Особенности

* Используется реже чем `LEFT JOIN` (обычно меняют порядок таблиц и пишут `LEFT`).

---

## 4. FULL \[OUTER] JOIN (полное внешнее соединение)

### 4.1. Описание

Возвращает все строки из обеих таблиц. При отсутствии совпадения в одной из — соответствующие поля другой будут `NULL`.

### 4.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
FULL [OUTER] JOIN B
  ON A.поле = B.поле;
```

### 4.3. Пример

```sql
SELECT u.id AS user_id, o.id AS order_id
FROM users u
FULL JOIN orders o
  ON u.id = o.user_id;
```

* **Результат**:

    * Пользователи без заказов → `order_id = NULL`
    * Заказы без пользователей → `user_id = NULL`

### 4.4. Особенности

* Полезно для синхронизации данных или выявления «разнобоя» между таблицами.
* Может генерировать много `NULL`-строк, требует аккуратного фильтра `WHERE`.

---

## 5. CROSS JOIN (декартово произведение)

### 5.1. Описание

Генерирует все возможные комбинации строк из двух таблиц (каждая строка A соединяется со всеми строками B).

### 5.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
CROSS JOIN B;
```

или

```sql
SELECT <столбцы>
FROM A, B;  -- старый синтаксис
```

### 5.3. Пример

```sql
SELECT u.username, p.name AS product
FROM users u
CROSS JOIN products p;
```

* **Результат**: каждая пара (пользователь, продукт).

### 5.4. Особенности

* Быстро растёт число строк (|A|×|B|).
* Применяется редко: генерация матриц, тестовых данных, комбинаций.

---

## 6. NATURAL JOIN

### 6.1. Описание

Автоматически соединяет таблицы по всем столбцам с одинаковыми именами.

### 6.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
NATURAL [INNER|LEFT|RIGHT|FULL] JOIN B;
```

### 6.3. Пример

```sql
-- если в users и orders есть поле user_id
SELECT *
FROM users
NATURAL JOIN orders;
```

* **Результат**: как `INNER JOIN ON users.user_id = orders.user_id`, но без явного указания.

### 6.4. Особенности

* **Осторожно!** Автоматизм может скрыть неожиданное совпадение по не тем колонкам.
* Рекомендуется применять лишь в простых случаях, когда вы точно знаете структуру.

---

## 7. JOIN … USING (соединение по перечисленным столбцам)

### 7.1. Описание

Упрощённый синтаксис, когда имя поля совпадает в обеих таблицах. При этом в результирующем наборе это поле выводится **один раз**.

### 7.2. Синтаксис

```sql
SELECT <столбцы>
FROM A
JOIN B
  USING (общий_столбец1, общий_столбец2);
```

### 7.3. Пример

```sql
SELECT id, username, total
FROM users
LEFT JOIN orders USING (user_id);
```

* В результате поле `user_id` будет единожды, без префиксов `users.user_id` и `orders.user_id`.

### 7.4. Особенности

* Удобно, когда много общих колонок.
* Под капотом эквивалентно `ON A.col = B.col`.

---

## 8. LATERAL JOIN (латеральное соединение)

### 8.1. Описание

Позволяет подзапросу в `FROM` ссылаться на столбцы предыдущих таблиц в том же списке `FROM`.

### 8.2. Синтаксис

```sql
SELECT …
FROM A
LEFT JOIN LATERAL (
  <подзапрос, использующий A.колонку>
) AS sub
  ON true;  -- или другое условие
```

### 8.3. Пример: топ-3 последних заказа для каждого пользователя

```sql
SELECT u.id, u.username, o_list.orders
FROM users u
LEFT JOIN LATERAL (
  SELECT json_agg(o) AS orders
  FROM (
    SELECT id, total
    FROM orders
    WHERE user_id = u.id
    ORDER BY created_at DESC
    LIMIT 3
  ) o
) o_list ON true;
```

### 8.4. Особенности

* Очень гибко: кореллированные подзапросы, парсинг JSON, агрегаты.
* Может быть дороже по производительности, чем простые JOIN’ы, если не оптимизировать.

---

## 9. SEMI-JOIN и ANTI-JOIN (частичные соединения)

PostgreSQL не имеет ключевых слов `SEMI JOIN`/`ANTI JOIN`, но их можно «эмулировать»:

### 9.1. SEMI-JOIN (эквивалент EXISTS)

* **Цель:** выбрать строки из A, для которых существует хотя бы одна строка в B.
* **Реализация через EXISTS:**

  ```sql
  SELECT *
  FROM A
  WHERE EXISTS (
    SELECT 1
    FROM B
    WHERE B.x = A.x
  );
  ```

### 9.2. ANTI-JOIN (эквивалент NOT EXISTS)

* **Цель:** выбрать строки из A, для которых нет ни одной строки в B.
* **Реализация через NOT EXISTS:**

  ```sql
  SELECT *
  FROM A
  WHERE NOT EXISTS (
    SELECT 1
    FROM B
    WHERE B.x = A.x
  );
  ```

### 9.3. Польза в оптимизации

* Под PostgreSQL планы могут использовать **“Semi Join”** / **“Anti Join”** операторы в `EXPLAIN`.
* Часто эффективнее `LEFT JOIN … WHERE B.pk IS NULL` для anti-join.

---

## 10. SELF JOIN (самосоединение)

### 10.1. Описание

Соединение таблицы самой с собой — применяется для иерархий или сравнений внутри набора.

### 10.2. Пример: соседние строки по дате

```sql
SELECT a.id, a.logdate, b.logdate AS next_date
FROM events a
LEFT JOIN events b
  ON b.logdate = (
    SELECT MIN(logdate)
    FROM events
    WHERE logdate > a.logdate
  );
```

---

## 11. Параметры оптимизации JOIN

1. **Индексы**

    * Обязательно индексировать поля, по которым идёт `ON`/`USING`.
2. **Типы сканов**

    * `Nested Loop` — хорошо на малых наборах или при наличии индекса.
    * `Hash Join` — эффективен, когда нужно объединить большие наборы без индексов.
    * `Merge Join` — когда оба входящих потока уже отсортированы.
3. **ANALYZE** и **EXPLAIN ANALYZE**

    * Обновляйте статистику (`VACUUM ANALYZE`), чтобы планировщик выбрал оптимальный метод.
4. **JOIN Order**

    * Порядок таблиц важен для `Nested Loop` и `Merge Join`. Можно задавать через `SET join_collapse_limit`.
