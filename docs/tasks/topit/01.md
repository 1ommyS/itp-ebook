1) Фильтрация отрицательных чисел

Вход: List<Integer> nums = [3, -1, 0, 5, -7, 2] <br>
Выход: [3, 0, 5, 2] <br>
Советы: фильтруй по условию x >= 0; проверь порядок элементов (должен сохраниться). <br>

2) Удаление дубликатов с сохранением порядка

Вход: ["a", "b", "a", "c", "b"] <br>
Выход: ["a", "b", "c"] <br>
Советы: используйте LinkedHashSet или stream().distinct(); убедись, что первый порядок сохранён. <br>

3) Подсчёт частот слов

Вход: ["to","be","or","not","to","be"] <br>
Выход: {to=2, be=2, or=1, not=1} <br> 
Советы: Collectors.groupingBy(w -> w, counting()); итог — Map<String, Long>. <br>

4) Поиск минимума и максимума

Вход: [10, -4, 33, 2, 2] <br>
Выход: min = -4, max = 33 <br> 
Советы: min, max через стрим; обработай пустую коллекцию (Optional). <br>

5) Склейка строк через запятую

Вход: ["red","green","blue"] <br> 
Выход: "red,green,blue" <br>
Советы: Collectors.joining(","); следи за пробелами. <br>

6) Преобразование в UPPERCASE и сортировка 

Вход: ["Bob","alice","bob"] <br>
Выход: ["ALICE","BOB","BOB"] <br>
Советы: сначала map(String::toUpperCase), затем sorted() по умолчанию.<br>

7) Чётные квадраты

Вход: [1,2,3,4,5,6]<br>
Выход: [4,16,36]<br>
Советы: filter(x % 2 == 0), затем map(x -> x * x); порядок важен.<br>

8) Сумма уникальных нечётных

Вход: [1,3,3,5,6,7,7]<br>
Выход: 16 (1+3+5+7)<br>
Советы: filter(odd) → distinct() → sum; аккуратно с типом результата (int/long).<br>

9) Объединение двух списков без дублей (с сохранением порядка первых появлений)

Вход: L1: [1,2,3], L2: [3,4,5,1]<br>
Выход: [1,2,3,4,5]<br>
Советы: конкатенация стримов → distinct(); либо в LinkedHashSet.<br>

10) Сортировка объектов Person по возрасту

Вход (Person{id,name,age}):<br>
[(1,"Ann",30), (2,"Bob",25), (3,"Cara",25), (4,"Dan",35)]<br>
Выход (порядок имен): [Bob(25), Cara(25), Ann(30), Dan(35)]<br>
Советы: Comparator.comparing(Person::getAge); убедись, что стабильность не требуется явно.<br>

11) Группировка людей по городу

Вход (name,city):<br>
Ann/Helsinki, Bob/Tampere, Cara/Helsinki, Dan/Turku, Eve/Helsinki<br>
Выход:<br>
{"Helsinki":[Ann,Cara,Eve], "Tampere":[Bob], "Turku":[Dan]}<br>
Советы: groupingBy(Person::getCity); при выводе можно показать только имена.<br>

12) Самый старший человек в каждом городе

Вход (name,city,age):<br>
Ann/Helsinki/30, Cara/Helsinki/25, Eve/Helsinki/40, Bob/Tampere/25, Dan/Turku/35<br>
Выход:<br>
{"Helsinki": Eve(40), "Tampere": Bob(25), "Turku": Dan(35)}<br>
Советы: groupingBy(..., collectingAndThen(maxBy(...), Optional::get)); проверь непустые группы.<br>

13) Частоты первых букв имён (регистр игнорируем)

Вход: ["Anna","Artem","Boris","Bella","Chris","anna"]<br>
Выход: {a=3, b=2, c=1}<br>
Советы: нормализуй к нижнему регистру, бери charAt(0), groupingBy + counting().<br>

14) Сумма заказов по клиенту

Вход (customerId, amount):
("c1", 100.50), ("c2", 200.00), ("c1", 49.50)<br>
Выход: {"c1"=150.00, "c2"=200.00}<br>
Советы: финансы — лучше BigDecimal; groupingBy(..., reducing/summing).<br>

15) Плоский список тегов без дублей, сортировка

Вход: [["java","streams"], ["collections","java"], [], ["io"]]<br>
Выход: ["collections","io","java","streams"]<br>
Советы: flatMap, потом distinct, потом sorted.<br>

16) Парсинг CSV-строк в объекты с учётом ошибок

Вход (строки "id;name;age"):<br>
["1;Ann;30", "X;Bad;??", "2;Bob;25"]<br>
Выход:<br>

Валидные ID: [1, 2]<br>

Невалидные строки: 1<br>
Советы: парси id и age как числа с try-catch (NumberFormatException); собирай статистику.<br>

17) Безопасное чтение из Map с дефолтом/Optional

Вход: map={"a":1, "b":null}, запрос ключей: ["a","b","c"]<br>
Выход: ["1","N/A","N/A"]<br>
Советы: getOrDefault не отличает null и отсутствия — комбинируй с Optional.ofNullable.<br>

18) Парсинг чисел из строк с пропуском ошибок

Вход: ["10","-3","foo","7","bar"]<br>
Выход:<br>

Успешно распарсенные: [10, -3, 7]<br>

Пропущено: 2<br>
Советы: оборачивай парсинг в try-catch, не прерывай поток, веди счётчик ошибок.<br>

19) Деление пар чисел с обработкой деления на ноль

Вход (num,den): [(10,2),(3,0),(7,1)]<br>
Выход:<br>
[5.0, ERROR: ArithmeticException, 7.0]<br>

Успехов: 2, Ошибок: 1<br>
Советы: try-catch (ArithmeticException) на каждую пару; отдели результаты и ошибки.<br>

20) Валидация e-mail с кастомным исключением

Вход: ["a@b.com","invalid","user@domain","x@y.z"]<br>
Выход:<br>

Невалидные: ["invalid","user@domain"]<br>

Валидные: ["a@b.com","x@y.z"]<br>
Советы: создай InvalidEmailException; простая проверка: наличие @ и точки после @ (для учебной задачи).<br>

21) Подсчёт непустых строк «из файла»

Вход (содержимое): ["Hello","", "Java", " "] (пустые и пробельные исключаем)<br>
Выход: непустых строк = 2<br>
Советы: применяй trim().isEmpty(); в реале — try-with-resources и Files.lines(...).<br>

22) Сортировка продуктов по цене ↑, затем рейтингу ↓

Вход (id, price, rating):<br>
p1(10,4.5), p2(10,4.8), p3(8,4.9), p4(8,4.0)<br>
Выход (порядок id): [p3, p4, p2, p1]<br>
Советы: Comparator.comparing(Product::getPrice).thenComparing(Product::getRating, reverseOrder()).<br>

23) Оставить по одному продукту на категорию (первое вхождение)

Вход (id, category):<br>
p1/A, p2/B, p3/A, p4/C, p5/B<br>
Выход: [p1(A), p2(B), p4(C)]<br>
Советы: toMap(category, product, keepFirst) или предикат distinctByKey с Set.<br>

24) Пагинация: пропустить и взять

Вход: числа 1..10, skip=3, limit=4<br>
Выход: [4,5,6,7]<br>
Советы: проверь граничные случаи: когда skip ≥ размера; порядок не меняется.<br>

25) Сведение (reduce) к строке в квадратных скобках

Вход: ["a","b","c"]<br>
Выход: "[a,b,c]"<br>
Советы: лучше Collectors.joining(",", "[", "]"); через reduce — обработай пустой список.<br>

26) Слияние двух карт с суммированием значений

Вход: m1={a=2, b=1}, m2={b=5, c=3}<br>
Выход: {a=2, b=6, c=3}<br>
Советы: Stream.of(m1,m2) → flatMap(entrySet) → toMap(key, val, Integer::sum).<br>

27) Топ-3 наибольших с учётом дубликатов

Вход: [5,1,9,3,9,8]<br>
Выход: [9,9,8]<br>
Советы: sorted(reverse) → limit(3); оговори, считаем дубликаты валидными.<br>

28) Преобразование списка Person в Map по id (демонстрация ошибки)

Вход (id,name): [(1,"Ann"), (2,"Bob"), (2,"Bill")]<br>
Ожидаемо: при Collectors.toMap(Person::getId, Function.identity())<br>
Выход: будет брошено IllegalStateException (дублирующийся ключ 2)<br>
Советы: добавь merge-функцию (выбрать первый/последний) или предварительно проверяй уникальность.<br>

29) Поиск имени страховой через Optional-цепочку

Вход (Person → Car → Insurance → name):<br>

John: есть Car, Insurance "Allianz"<br>

Mary: есть Car, Insurance null<br>

Alex: Car = null<br>
Выход: {"John":"Allianz","Mary":"unknown","Alex":"unknown"}<br>
Советы: map/flatMap с Optional, orElse("unknown"); избегай NullPointerException.<br>

30) Имитация LRU-кэша (LinkedHashMap accessOrder=true)

Вход (capacity=3, операции):<br>
put(A,1), put(B,2), put(C,3), get(A), put(D,4)<br>
Выход:<br>

Хиты: 1 (get(A))<br>

Промахи: 0<br>

Итоговый порядок ключей (от старого к новому): [C, A, D] (B вытеснен)<br>
Советы: используй LinkedHashMap с accessOrder=true и removeEldestEntry; обновление порядка при get.<br>

Как использовать эти задачи максимально эффективно<br>

Иди строго по порядку; не прыгай к 30-й, пока не почувствуешь лёгкость на предыдущих.<br>

На каждую задачу пиши 1–2 теста со своими входами (в т.ч. пустые коллекции, null поля, повторы).<br>

Для задач с деньгами — сразу приучайся к BigDecimal.<br>

Для задач с ошибками — логируй и собирай статистику (сколько удачных, сколько упавших).<br>

Для задач с объектами — продумывай поля и инварианты (например, age >= 0).<br>