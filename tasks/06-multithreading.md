
## Задача 1. Потокобезопасный счётчик с ReentrantLock

**Описание**  
Реализуйте класс `SafeCounter`, который инкапсулирует в себе целочисленный счётчик и обеспечивает возможность корректного увеличения и считывания его значения несколькими потоками одновременно. Используйте `ReentrantLock`, чтобы гарантировать целостность данных.

**Требования**
1. Поле `counter` должно быть приватным целым числом.
2. Метод `increment()` увеличивает значение счётчика на 1.
3. Метод `getValue()` возвращает текущее значение счётчика.
4. В тестовом коде создайте несколько потоков, которые многократно вызывают `increment()`, и проверьте корректность результата.

**Подсказка**
- Для захвата и освобождения блокировки используйте конструкцию:
  ```java
  lock.lock();
  try {
      // критическая секция
  } finally {
      lock.unlock();
  }
  ```

---

## Задача 2. Логирование сообщений в общий список

**Описание**  
Реализуйте класс `ThreadSafeLogger`, позволяющий потокам добавлять сообщения в общий список логов. Каждый поток будет записывать несколько сообщений. В конце работы всех потоков необходимо распечатать итоговый список.

**Требования**
1. Использовать `ReentrantLock` для защиты общей коллекции (например, `ArrayList<String>`).
2. Методы:
    - `log(String message)` — добавляет сообщение в список.
    - `getLogs()` — возвращает копию списка всех логов.
3. Продемонстрировать работу с несколькими потоками.

**Подсказка**
- Для обеспечения потокобезопасного доступа к списку в методах `log()` и `getLogs()` нужно блокироваться на одном и том же `ReentrantLock`.
---

## Задача 3. «Гонки» при доступе к ресурсу

**Описание**  
Создайте класс `RaceConditionDemo`, который демонстрирует, как может возникнуть состояние гонки (Race Condition) при некорректном использовании общей переменной несколькими потоками. Задача — увидеть проблему, а затем решить её с помощью `ReentrantLock`.

**Требования**
1. В начале создайте вариант без блокировок, где несколько потоков инкрементируют и декрементируют одно и то же поле. Наблюдайте несогласованность.
2. Затем добавьте `ReentrantLock` и исправьте проблему.

**Подсказка**
- Для ясности можно сделать класс, содержащий поле `int balance` и методы `increment()` и `decrement()`. Запускать параллельно несколько потоков, которые часто повторяют эти операции.
---

## Задача 4. «Суммирование» из разных потоков

**Описание**  
Реализуйте класс `Summator`, который в параллельных потоках суммирует числа из нескольких массивов/списков и накапливает общий результат. Главная цель — обеспечить корректность итоговой суммы.

**Требования**
1. Поле `totalSum` должно хранить общую сумму.
2. Несколько потоков должны суммировать разные (или одинаковые) наборы чисел и добавлять результат в `totalSum`.
3. Использовать `ReentrantLock` для защиты общего результата.

**Подсказка**
- Можно эмулировать «долгую» работу, используя `Thread.sleep()`, чтобы ещё нагляднее увидеть проблему в отсутствии блокировки.

---

## Задача 5. Переключение флага с использованием нескольких потоков

**Описание**  
Допустим, у вас есть логический флаг (boolean), который может быть `true` или `false`. Несколько потоков могут устанавливать его в `true`, а другие — снова в `false`. Создайте класс `ToggleFlag`, в котором:
1. Используется `ReentrantLock` для доступа к полю `flag`.
2. Метод `setTrue()` устанавливает `flag = true`.
3. Метод `setFalse()` устанавливает `flag = false`.
4. Метод `isFlag()` возвращает текущее значение флага.
5. В `main` продемонстрируйте, как несколько потоков настраивают флаг поочерёдно.

**Подсказка**
- Чтобы увидеть динамику, можно выводить в консоль состояние флага после каждого изменения.
---

## Задача 6*. Реализация ConcurrentHashMap через ReadWriteLock

**Описание**  
В этой задаче вам нужно реализовать упрощённую версию `ConcurrentHashMap`, используя `ReadWriteLock` (например, `ReentrantReadWriteLock`), который позволит организовать совместное чтение и эксклюзивную запись.  
Сделайте класс `MyConcurrentHashMap<K, V>`, в котором будет храниться обычная `HashMap<K, V>`, а доступ к ней будет защищён `ReadWriteLock`.

**Основной функционал**
1. `V get(K key)`: возвращает значение по ключу. При чтении используйте `readLock`.
2. `V put(K key, V value)`: добавляет или изменяет значение по ключу. При записи используйте `writeLock`.
3. `V remove(K key)`: удаляет ключ и значение из мапы, используя `writeLock`.
4. `boolean containsKey(K key)`: возвращает `true`, если ключ есть в мапе. Для проверки используйте `readLock`.

**Подсказка**
- Не забывайте блокировать чтение и запись корректно. Чтение можно делать параллельно из нескольких потоков, а запись должна быть эксклюзивной.
- Используйте структуру `ReentrantReadWriteLock lock = new ReentrantReadWriteLock();`, тогда для чтения у вас будет `lock.readLock()`, а для записи — `lock.writeLock()`.

---

## Задача 7*. Очередь заданий с использованием Condition (прочитайте про класс Condition)

**Описание**  
Создайте класс `TaskQueue`, который хранит задания (например, строки или любые другие объекты) в очереди и позволяет:
1. Потокам-добавляльщикам `put(task)` класть задание в очередь.
2. Потокам-исполнителям `take()` забирать задание из очереди.
3. Если очередь пуста — поток, который вызывает `take()`, должен ждать, пока не появится новая задача.
4. Если очередь переполнена (например, ограничение размера 10), поток, который вызывает `put()`, должен ждать, пока не освободится место.

Для этого используйте `ReentrantLock` и два объекта `Condition`:
- Один для уведомления о появлении задачи (чтобы `take()` не ждал зря).
- Второй для уведомления о появлении свободного места (чтобы `put()` не ждал зря).

**Подсказка**
- При работе с `Condition` используются методы `await()` и `signal()`/`signalAll()`.
- Не забудьте, что вызовы `await()` и `signal()` нужно делать внутри блока `lock.lock()/unlock`.
