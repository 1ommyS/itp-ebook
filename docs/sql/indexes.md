## 1. Зачем нужны индексы

* **Ускорение поиска** (`SELECT … WHERE`), сортировки (`ORDER BY`), группировки (`GROUP BY`), проверки уникальности.
* **Поддержка целостности** (`UNIQUE`, `PRIMARY KEY` автоматически создают индекс).
* **Снижение нагрузки** на полный просмотр таблицы (sequential scan).

Однако индексы:

* Потребляют дисковое пространство.
* Замедляют `INSERT`/`UPDATE`/`DELETE` (надо поддерживать структуру).

Поэтому важен выбор правильного типа и покрытия.

---

## 2. Индексы по структуре данных

### 2.1. B-Tree (по умолчанию)

* **Структура:** сбалансированное дерево; листья содержат указатели на строки.
* **Поддерживает:** `=`, `<`, `<=`, `>`, `>=`, `BETWEEN`, `LIKE 'abc%'`.
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING btree (столбец [COLLATE ...] [ASC|DESC]);
  ```
* **Пример:**

  ```sql
  CREATE INDEX idx_users_created
    ON users (created_at DESC);
  ```
* **Плюсы:**

    * Самый универсальный.
    * Хорошая производительность для диапазонных и точных запросов.
* **Минусы:**

    * Неэффективен для полнотекстового поиска, массивов, гео-данных.

### 2.2. Hash

* **Структура:** хеш-таблица.
* **Поддерживает:** только точное равенство `=` (и `IN`).
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING hash (столбец);
  ```
* **Пример:**

  ```sql
  CREATE INDEX idx_users_email_hash
    ON users USING hash (email);
  ```
* **Плюсы:**

    * Очень быстрый `=`-поиск (в памяти).
* **Минусы:**

    * Не поддерживает диапазоны.
    * Хеш-индексы в старых версиях PostgreSQL были нестабильны; сейчас в 13+ достаточно надёжны.
    * Нет поддержки `ORDER BY`.

### 2.3. GiST (Generalized Search Tree)

* **Структура:** обобщённое сбалансированное дерево для «приложений».
* **Поддерживает:** широкий спектр операторов, если реализован операторный класс (например, `&&` для диапазонов, геометрии, полнотекстовых векторов через `tsvector`).
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING gist (столбец);
  ```
* **Примеры:**

  ```sql
  -- Для гео-данных (PostGIS)
  CREATE INDEX idx_locations_geom
    ON locations USING gist (geom);

  -- Для диапазонов (tsrange, int4range)
  CREATE INDEX idx_events_period
    ON events USING gist (period);
  ```
* **Плюсы:**

    * Гибкость: любая структура с поддержкой операций «пересечения», «вложенности» и т.д.
    * Отлично подходит для геоданных, диапазонов, полнотекста (`tsvector` через GIN, но GiST тоже возможен).
* **Минусы:**

    * Более медленный, чем B-Tree, для простых запросов.
    * Требует настройки статистики и параметров `fillfactor`.

### 2.4. GIN (Generalized Inverted Index)

* **Структура:** «обратный» список — для каждого ключа хранит список с указателями строк.
* **Поддерживает:**

    * Полнотекстовый поиск (`tsvector`).
    * Массивы (`ANY`), JSONB (`@>`, `?`), документы.
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING gin (столбец);
  ```
* **Пример:**

  ```sql
  -- Полнотекстовый индекс
  CREATE INDEX idx_docs_text
    ON documents USING gin (to_tsvector('russian', body));

  -- JSONB: быстрое поиск по ключам/значениям
  CREATE INDEX idx_data_jsonb
    ON items USING gin (data jsonb_path_ops);
  ```
* **Плюсы:**

    * Высокая скорость поиска по множеству элементов (токенов, ключей).
* **Минусы:**

    * Большой объём на диске.
    * Медленнее обновление при `INSERT`/`UPDATE`.

### 2.5. SP-GiST (Space-partitioned GiST)

* **Структура:** дерево, оптимизированное под разреженные данные и специфические пространства (например, квадродерево, trie).
* **Поддерживает:** текстовые префиксные запросы, геометрические структуры, IP-сети.
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING spgist (столбец);
  ```
* **Пример:**

  ```sql
  -- Трие-индекс для текста
  CREATE INDEX idx_text_trgm
    ON docs USING spgist (body gist_trgm_ops);
  ```
* **Плюсы:**

    * Эффективен для некоторых нетривиальных задач (IP-сети, триграммы).
    * Занимает меньше места, чем GiST в ряде случаев.
* **Минусы:**

    * Меньше случаев, где применим; сложнее настраивать.

### 2.6. BRIN (Block Range Index)

* **Структура:** хранит минимальные/максимальные значения на диапазон блоков страницы (каждый блок \~1GB данных).
* **Поддерживает:** все типы, но эффективно только для «примерно упорядоченных» данных (даты, наружные ключи по порядку загрузки).
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING brin (столбец [WITH (options)]);
  ```
* **Пример:**

  ```sql
  CREATE INDEX idx_logs_time_brin
    ON logs USING brin (event_time);
  ```
* **Плюсы:**

    * Очень маленький размер.
    * Быстрая выборка, если данные лежат «локально» по диапазонам.
* **Минусы:**

    * Сильно уступает B-Tree, если данные хаотичны.
    * Может пропускать большие фрагменты, требуя seq scan.

---

## 3. Индексы по типу покрытия

### 3.1. Полный индекс (Full)

* **Что это:** индекс, охватывающий все строки таблицы.
* **Применение:** любой обычный индекс (`B-Tree`, `GIN` и т.д.) — по умолчанию полный.
* **Плюсы:** покрывает весь набор данных, всегда будет доступен для запросов.
* **Минусы:** максимальный размер, максимальные накладные расходы на запись.

### 3.2. Частичный индекс (Partial)

* **Что это:** индекс только по подмножеству строк, удовлетворяющих условию `WHERE`.
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING btree (столбец)
    WHERE условие;
  ```
* **Пример:**

  ```sql
  -- Индекс только по активным пользователям
  CREATE INDEX idx_active_users
    ON users (last_login)
    WHERE active = TRUE;
  ```
* **Плюсы:**

    * Меньше размер.
    * Оптимизация «горячих» запросов (например, только текущие или только «недавно изменённые» строки).
* **Минусы:**

    * PostgreSQL может не применить его, если условие в запросе не точно совпадает с `WHERE` индекса.
    * Требует тщательного планирования условий.

### 3.3. Покрывающий индекс (Covering / INCLUDE)

* **Что это:** индекс, в котором помимо ключевых столбцов могут храниться дополнительные (non-key) столбцы, чтобы обеспечить *index-only scan*.
* **Синтаксис:**

  ```sql
  CREATE INDEX имя_idx ON таблица USING btree (ключ1, ключ2)
    INCLUDE (доп1, доп2);
  ```
* **Пример:**

  ```sql
  -- Индекс по дате создания, но покрывающий поля для запроса
  CREATE INDEX idx_posts_created_incl
    ON posts (created_at)
    INCLUDE (author_id, title);
  ```
* **Как работает:**

    * При `SELECT created_at, author_id, title …` сервер может брать все данные из индекса, не читая саму таблицу.
* **Плюсы:**

    * Снижение I/O: index-only scan.
    * Можно добавить редко изменяемые поля без увеличения глубины чередования ключей.
* **Минусы:**

    * INCLUDE-столбцы не участвуют в поиске/сортировке.
    * Увеличивает размер индекса за счёт дополнительных данных.

---

## 4. Рекомендации по выбору

1. **В большинстве случаев** — B-Tree по ключу фильтрации или сортировки.
2. **Для равенства** на больших текстовых полях или JSONB — GIN.
3. **Для гео-данных и диапазонов** — GiST либо BRIN/EXCLUDE для перекрытия.
4. **Если нужен быстрый `=`** без диапазонов — Hash (в PostgreSQL 13+).
5. **Большие «архивные» таблицы** с упорядоченными по дате данными — BRIN.
6. **Index-only scan** — используйте покрывающие индексы с `INCLUDE`.
7. **Частичный индекс** — для «горячих» подмножеств (active, recent).
