### HashMap и HashSet в Java

В языке программирования Java коллекции `HashMap` и `HashSet` являются одними из самых часто используемых структур данных благодаря своей эффективности и гибкости. В этом разделе мы подробно рассмотрим их внутреннее устройство, принципы работы, а также сравним `HashMap` с `Hashtable`.

---

### Содержание

1. [Введение в HashMap и HashSet](#1-введение-в-hashmap-и-hashset)
2. [Устройство HashMap](#2-устройство-hashmap)
    - [Основные компоненты HashMap](#21-основные-компоненты-hashmap)
    - [Хэш-функция и индексация](#22-хэш-функция-и-индексация)
    - [Обработка коллизий](#23-обработка-коллизий)
    - [Динамическое изменение размера](#24-динамическое-изменение-размера)
    - [Важные параметры HashMap](#25-важные-параметры-hashmap)
3. [Устройство HashSet](#3-устройство-hashset)
4. [Различия между HashMap и Hashtable](#4-различия-между-hashmap-и-hashtable)
5. [Примеры использования](#5-примеры-использования)
6. [Заключение](#6-заключение)

---

### 1. Введение в HashMap и HashSet

**`HashMap`** и **`HashSet`** — это реализации коллекций, основанных на хешировании, предоставляющие быстрый доступ к элементам. Они широко используются для хранения уникальных элементов (`HashSet`) или пар ключ-значение (`HashMap`) с возможностью быстрого поиска, добавления и удаления.

- **`HashMap<K, V>`**: Сохраняет элементы в виде пар ключ-значение. Позволяет быстро получать значение по ключу.
- **`HashSet<E>`**: Хранит уникальные элементы без связанных значений. Основан на `HashMap`, где элементы являются ключами, а значения — фиктивными объектами.

---

### 2. Устройство HashMap

`HashMap` реализует интерфейс `Map`, предоставляя структуру данных для хранения пар ключ-значение. Основной принцип работы `HashMap` основан на использовании хеш-функции для распределения ключей по различным "бакетам" (корзинам).

#### 2.1. Основные компоненты HashMap

- **Бакеты (Buckets)**: Основная структура данных — массив, где каждый элемент представляет собой бакет, содержащий список или дерево элементов с одинаковым хеш-кодом.
- **Ноды (Nodes)**: Каждый элемент в бакете представлен объектом `Node<K, V>`, содержащим ключ, значение, хеш-код и ссылку на следующий элемент (для связного списка).
- **Хэш-функция**: Преобразует ключ в индекс бакета в массиве.
- **Порог нагрузки (Load Factor)**: Определяет, когда `HashMap` должен увеличиться в размере для поддержания эффективности операций.

#### 2.2. Хэш-функция и индексация

При добавлении элемента в `HashMap` выполняются следующие шаги:

1. **Вычисление хеш-кода**: Метод `hashCode()` вызывается для ключа, чтобы получить его хеш-код.
2. **Распределение по бакетам**: Хеш-код преобразуется в индекс бакета с помощью формулы `index = (n - 1) & hash`, где `n` — размер массива бакетов.
3. **Размещение элемента**: Если бакет пуст, создается новая нода. Если бакет уже содержит элементы с таким же хеш-кодом, происходит сравнение ключей для определения, заменить ли существующее значение или добавить новый элемент.

**Пример вычисления индекса бакета:**

```java
int hash = key.hashCode();
int index = (array.length - 1) & hash;
```

#### 2.3. Обработка коллизий

**Коллизия** возникает, когда два разных ключа имеют одинаковый хеш-код или хеш-коды, приводящие к одному и тому же индексу бакета. В `HashMap` коллизии обрабатываются следующими способами:

1. **Связные списки (до Java 8)**: Все элементы с одинаковым индексом бакета хранятся в связном списке. При поиске элемента необходимо пройти по списку и сравнить ключи.
2. **Деревья (с Java 8)**: Если количество элементов в бакете превышает определенный порог (обычно 8), связный список преобразуется в красно-черное дерево, что улучшает время поиска с O(n) до O(log n).

**Пример структуры бакета с коллизиями:**

```
Bucket index 5:
Node1 (key1, value1) -> Node2 (key2, value2) -> Node3 (key3, value3)
```

#### 2.4. Динамическое изменение размера

`HashMap` автоматически увеличивает размер массива бакетов, когда количество элементов превышает порог нагрузки (`loadFactor * currentCapacity`). При увеличении размера происходит **перехеширование** — пересчет индексов для всех существующих элементов и их перемещение в новые бакеты.

**Пример увеличения размера:**

```java
if (size > threshold) {
    resize();
}
```

#### 2.5. Важные параметры HashMap

- **Начальная емкость (Initial Capacity)**: Размер массива бакетов при создании `HashMap`. По умолчанию 16.
- **Фактор нагрузки (Load Factor)**: Определяет порог для увеличения размера. По умолчанию 0.75.
- **Текущая емкость (Current Capacity)**: Текущий размер массива бакетов.
- **Порог (Threshold)**: Значение `currentCapacity * loadFactor`, при превышении которого происходит ресайз.

**Пример создания HashMap с заданной начальной емкостью и фактором нагрузки:**

```java
Map<String, Integer> map = new HashMap<>(32, 0.8f);
```

---

### 3. Устройство HashSet

`HashSet` реализует интерфейс `Set` и предназначен для хранения уникальных элементов без связанных значений. Внутренне `HashSet` использует `HashMap`, где элементы множества хранятся в качестве ключей, а значения являются фиктивными объектами (`PRESENT`).

#### Основные особенности HashSet:

- **Уникальность**: `HashSet` не допускает дубликатов элементов.
- **Нет порядка**: Элементы не гарантированно упорядочены.
- **Быстрый доступ**: Операции добавления, удаления и поиска имеют среднюю временную сложность O(1).

#### Внутреннее устройство HashSet:

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    private static final Object PRESENT = new Object();
    private transient HashMap<E, Object> map;
    
    public HashSet() {
        map = new HashMap<>();
    }

    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }

    // Другие методы делегируются HashMap
}
```

**Преимущества использования HashSet:**

- Эффективность при проверке наличия элемента.
- Простота использования для хранения уникальных значений.

---

### 4. Различия между HashMap и Hashtable

`HashMap` и `Hashtable` обе реализуют интерфейс `Map`, но имеют ряд отличий в поведении и функциональности.

| **Особенность**              | **HashMap**                                   | **Hashtable**                                   |
|------------------------------|-----------------------------------------------|-------------------------------------------------|
| **Синхронизация**            | Не синхронизирована по умолчанию             | Синхронизирована по умолчанию                   |
| **Null ключи и значения**    | Позволяет один `null` ключ и неограниченное количество `null` значений | Не допускает `null` ключей и значений            |
| **Производительность**       | Более высокая в несинхронизированном режиме   | Ниже из-за синхронизации                         |
| **Наследование**             | Наследуется от `AbstractMap`                  | Наследуется от `Dictionary` (устаревший класс)   |
| **Методы**                   | Современные методы коллекций (`put`, `get`, `remove` и т.д.) | Старые методы (`put`, `get` из `Dictionary`)     |
| **Использование**            | Рекомендуется использовать `HashMap` вместо `Hashtable` | Рекомендуется использовать `HashMap` или `ConcurrentHashMap` |

**Основные отличия:**

1. **Синхронизация:**
    - `Hashtable` синхронизирована, что делает ее потокобезопасной без дополнительной синхронизации.
    - `HashMap` не синхронизирована, что обеспечивает более высокую производительность в однопоточных приложениях. Для многопоточных сценариев рекомендуется использовать `ConcurrentHashMap` или синхронизировать `HashMap` вручную.

2. **Null ключи и значения:**
    - `HashMap` допускает `null` ключи и значения, что может быть полезно в некоторых случаях.
    - `Hashtable` не допускает `null` ключей или значений, и попытка вставить `null` вызовет `NullPointerException`.

3. **Наследование и современные стандарты:**
    - `Hashtable` считается устаревшим (`legacy` класс) и не рекомендуется для использования в новых приложениях.
    - `HashMap` является частью коллекций Java и рекомендуется для использования в современных приложениях.

---

### 5. Примеры использования

#### 5.1. Использование HashMap

**Пример хранения и обработки данных о студентах:**

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // Создание HashMap для хранения студентов: ID -> Имя
        Map<Integer, String> studentMap = new HashMap<>();

        // Добавление элементов
        studentMap.put(101, "Анна");
        studentMap.put(102, "Борис");
        studentMap.put(103, "Виктор");
        studentMap.put(104, "Галина");

        // Получение значения по ключу
        String studentName = studentMap.get(102);
        System.out.println("Студент с ID 102: " + studentName); // Выведет: Борис

        // Итерация по ключам и значениям
        for (Map.Entry<Integer, String> entry : studentMap.entrySet()) {
            System.out.println("ID: " + entry.getKey() + ", Имя: " + entry.getValue());
        }

        // Проверка наличия ключа или значения
        boolean hasStudent103 = studentMap.containsKey(103);
        boolean hasNameMaria = studentMap.containsValue("Мария");
        System.out.println("Есть студент с ID 103? " + hasStudent103); // true
        System.out.println("Есть студент с именем Мария? " + hasNameMaria); // false
    }
}
```

**Вывод:**
```
Студент с ID 102: Борис
ID: 101, Имя: Анна
ID: 102, Имя: Борис
ID: 103, Имя: Виктор
ID: 104, Имя: Галина
Есть студент с ID 103? true
Есть студент с именем Мария? false
```

#### 5.2. Использование HashSet

**Пример хранения уникальных email адресов:**

```java
import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        // Создание HashSet для хранения email адресов
        Set<String> emailSet = new HashSet<>();

        // Добавление элементов
        emailSet.add("user1@example.com");
        emailSet.add("user2@example.com");
        emailSet.add("user3@example.com");
        emailSet.add("user1@example.com"); // Дубликат, не будет добавлен

        // Итерация по элементам
        for (String email : emailSet) {
            System.out.println("Email: " + email);
        }

        // Проверка наличия элемента
        boolean hasUser2 = emailSet.contains("user2@example.com");
        System.out.println("Есть ли user2@example.com? " + hasUser2); // true

        // Удаление элемента
        emailSet.remove("user3@example.com");
        System.out.println("После удаления user3@example.com:");
        emailSet.forEach(System.out::println);
    }
}
```

**Вывод:**
```
Email: user1@example.com
Email: user2@example.com
Есть ли user2@example.com? true
После удаления user3@example.com:
user1@example.com
user2@example.com
```

---

### 6. Заключение

**Ключевые моменты:**

- **HashMap** хранит пары ключ-значение, обеспечивая быстрый доступ к данным.
- **HashSet** обеспечивает хранение уникальных элементов без дублирования.
- **HashMap** не синхронизирована и допускает `null` ключи и значения, тогда как `Hashtable` синхронизирована и не допускает `null`.
- Правильный выбор между `HashMap` и `Hashtable` зависит от требований к потокобезопасности и функциональности приложения. НО ЛУЧШЕ `HashMap` или `ConcurrentHashMap`

---

### Дополнительные ресурсы

- **Документация Java по HashMap и HashSet:**
    - [HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)
    - [HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html)
- **Статьи и руководства:**
    - [HashMap vs Hashtable в Java](https://www.baeldung.com/java-hashmap-hashtable)
    - [Java Collections Framework Tutorial](https://www.baeldung.com/java-collections)
- **Книги:**
    - "Java: Полное руководство" — Герберт Шилдт
    - "Effective Java" — Joshua Bloch (разделы о коллекциях)

---